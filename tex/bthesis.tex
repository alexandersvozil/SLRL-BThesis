% Author: Alexander Svozil
% Matr.-nr.: 1026213
% TU Wien
\documentclass [12pt]{article}
\usepackage [utf8]{inputenc}
\usepackage {graphicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\bibliographystyle{ieeetr} 
\renewcommand{\algorithmicrequire}{\textbf{Input:}}

\begin{document}
\author{Alexander Svozil}
\title{Bachelor Thesis \\ The Server Location Problem with Restricted Loads 
on Servers and Links}

\maketitle

\section{Abstract}
The server location problem with restricted loads on servers and links (SLRL) is an NP-Complete
problem, introduced by Hiroyoshi Miwa et al. in the Paper "Method of Locating Mirror Servers
to Alleviate Load on Servers and Links" \cite{mirrorserver}. The problem 
came up, because the massive volume of data distributed by content delivery networks (CDNs) 
require well located mirror servers in order not to badly influence the quality of their service.
Two examples for CDNs would be "Amazon CloudFront" a traditional commercial CDN, or the "AT\&T Inc."
a Telco CDN which has advantages over traditional CDNs because they own the so called "last mile",
the final leg of the telecommunications networks. CDN nodes are usually deployed in multiple 
locations, often over multiple backbones, reaching thousands of nodes with tens of thousands of 
servers. \cite{wiki:cdn} \cite{wiki:lastmile}
The two constraints induced by the choice of mirror servers is the number of maximum nodes
accessing a mirror server and maximum number of nodes accessing a mirror server 
through a specific link. The constraint mentioned first, corresponds to the network load on
the (mirror-)servers. The second constraint corresponds to the restricted load on the links.
First I want to prove that SLRL is NP-complete. Next, I want to propose my own algorithm as a
sequel to the existing greedy algorithm proposed by Miwa et al. \cite{mirrorserver}.


\tableofcontents

\section{Introduction}
\subsection {CDNs}
"A content delivery network is a collaborative collection of network elements spanning
the Internet, where content is replicated over several mirrored Web servers in order
to perform transparent and effective delivery of content to the end user."\cite[p. 3]{Buyya:2008:CDN:1457653}
To perform efficient delivery of data, CDNs need to have several mirrored Web servers
and thus it is important to place them well, because placing the mirror server 
could be an expensive choice considering no prior calculation where it should go. 
The expensive choice manifests in high link usages and or a maximal neighbourhood being
too big for the server to handle.
The mirror servers naturally serve the same data, as they are there to alleviate the 
load of the other servers providing the data.

\subsection {Similar Problems}
A lot of thought has already been put into the server location problem.
Two problems that describe this problem would be the p-center and the
p-median problem. The purpose of these problems is mainly to shorten delay
time from the client to the server. 
\subsubsection {P-Center Problem}
"The p-Center problem consists of locating p facilities and assigning clients
to them in order to minimize the maximum distance between a client and the facility
to which he or she is allocated. It is used for example in locating fire stations or ambulances,
where the distance from the facilities 
to their farthest assigned potential client should be minimum."\cite{Mladenovic00solvingthe}
The p-center problem is one of the best known NP-hard discrete location problems.\cite{KarivHakimi1979}
For large instances, it is impractical to solve the problem exactly.
There have been very good results with the tabu-search and variable neighborhood search.
\cite{Mladenovic00solvingthe}
\subsubsection {P-Median Problem}
The p-Median Problem is very similar to the p-center problem. It can be defined as follows:
given a graph G=(V,E) we are asked to find a set of nodes, S, of size p, where $ S\subset V$, such that the weighted
sum of the distances from the remaining nodes \{V-S\} to the Set S is minimized. \cite{Rolland1997329}
This problem belongs to the class of problems known as NP-hard.\cite{KarivHakimi1979median} There have been
approaches to solve this problem with the tabu search \cite{Rolland1997329} and solving the linear program by
relaxing the binary constraints.\cite{rosing1979p}


\subsubsection {NA (Node to Area)-connectivity}
%%TODO: NA-Edge connectivity fehlt:
\subsection{Open Shortest Path First}
%%TODO: Facility Location with hops
\section{Server Location Problem with Restricted Loads on Servers and Links}
\subsection{Formal Definition}
\subsubsection{Neighbour Set}
The neighbour set is the set, that belongs to a server. In our problem, it is
defined as follows: If the node has a shortest path to a server node, he 
belongs to this server nodes neighbour set. If the node has several shortest
paths to multiple server nodes, it will belong to all of those server nodes neighbour
set. The server itself will belong to its own neighbour sets.
\subsubsection{Load on a Link, m(e) or multiplicity of an edge}
The load on a link is defined as follows: 
It is defined as the number of shortest paths, that cross a link. If there
are several shortest paths with the same length to one or more servers every
used edge is taken into account. This is done, because we must always consider
the worst case when locating a server.
\subsubsection{The Problem}
\textbf{Given:}
{\itshape Undirected graph G(V,E) and  positive integers k,r and c. \\
    $k = \|S\|$, where S is the set of servers $S = \{s_1,s_2,\dots s_k\} \subseteq V$\\
    r $\geq  \|V_i\|$ $(i=1,2,\dots,k)$ where $V_i$ is the neighbour set of $s_i$ $(i=1,2,\dots,k)$\\
$c \geq m(e)$, where m(e) is the maximum load $\forall e \in E$.} \\
\\
\textbf{Wanted:} 
{\itshape A set of Servers $S = \{s_1, s_2,\dots, s_k \} \subseteq V$ such that $|V_i|\leq r$
    $(i = 1,2, \dots,k)$ where $V_i$ is the neighbour set of $s_i$  $(i = 1,2,\dots,k)$ and that
$m(e) \leq c$ $(\forall e \in E)$.}

\subsection{An Instance Of The Problem}
\indent
\indent
\indent

\includegraphics [scale=0.23]{cableandwireless1.png}\\
The above shown graph is from the barebone network "Cable and Wireless".
It is parsed out of a dataset of barebone networks provided by caida.\cite{caidabarebones}
\\
The nodes have two values in their bubbles: "NH and m(e)". NH stands for 
the maximum neighbourhood if that node was chosen as a server. Choosing the first
server obviously implicates the maximum neighbourhood, because there are
no mirror servers yet on the graph.\\
The multiplicity of an edge e, $m(e)$ is explained above. The number after
$m(e)$ in the bubble describes $max(m(e))$ $ \forall e \in E$,
if one decides to take this node as a server.
The greedy algorithm takes the node with the lowest $max(m(e))$ first.
\\
\includegraphics [scale=0.23]{cableandwireless2.png}\\
This graph shows the second server pick. This time our $m(e)$ is already low enough
to suffice the constraint $m(e)\leq c $ thus the greedy algorithm proposed in the paper 
by Miwa et al. \cite{mirrorserver} chooses the node with the lowest max neighbourhood which is
coincidentally also the one with the lowest $m(e)$.


\subsection{Proof of NP-Completeness}
\section{Algorithm}
\subsection{Rules and Assumptions}
\subsection{Other Algorithms}
The only prior algorithm for this problem is the greedy algorithm proposed by
Miwa et al. \cite{mirrorserver}. It greedily chooses the node with the 
lowest maximal neighbourhood if the constraint $c\geq m(e) (\forall e \in E)$ is fulfilled. 
Otherwise it will choose a node where $min(m(e)(\forall e \in E))$ is true.

\subsection{Data (Testinstances)}
The data taken for the tests is from caida \cite{caidabarebones}. Parsing the
data was one of the most difficult parts, because the data is not formatted well.
It does not really follow the syntax proposed in the beginning of the file. I also
modified the data in some concerns:
\begin{itemize}
    \item If the graph G given for the barebone network was not connected,
        the connected component with less nodes of that graph is cut out.

    \item Normally the connected cities are listed in this manner:
        "city,state,country", in order to match with the numbers 
        in the paper \cite{mirrorserver} only city and state are used for
        identification and the country is left out. Sometimes London
        is used on one hand as City in Canada and on the other hand in GB, denoted like this
        London, *, Canada and London, *, England. They are differentiated.
    \item Sometimes the State has a number. One example would be "Kansas City, KS2~"
        This is interpreted as "Kansas City, KS".

\end{itemize}

All those modifications were done to match the graphs proposed by \cite{mirrorserver}.
As I did not have the data of the other paper used, I tried to match them with the number of
nodes and number of vertices. Unfortunately three instances of my instances do not
match the number of nodes and / or vertices proposed from the paper above.
The varying instances are: "Sprint", "Cable and Wireless" and "UUNet".

\subsection{Implementation}
I decided to implement a tabu-search.
    \subsection{Modified BFS}
    The Breadth first search needs to be modified in a way, that it finds all shortest paths
    from one node to another, as we need to consider every shortest path in order to simulate
    the worst case scenario regarding load on links.
    \begin{algorithm}[H]
        \caption{BFS2}
        \begin{algorithmic}[2]
            \Require Graph(V,E) G, Node dest, Node start
            \State $clearParents();$
            \State $resetDistance();$
            \State Queue$<$Node$>$ nodeQueue $\gets \{\};$
            \State Set$<$Node$>$ visited $\gets \{\};$
            \State $visited.add(start);$
            \State $nodeQueue.offer(start);$ \Comment \begin{itshape} Nodepair saves the node and the parentnode,
            so all the paths can be reconstructed\end{itshape}
            \While {$!nodeQueue.isEmpty()$}
            \State $Node$ $curNode$ $=$ $nodeQueue.poll();$ \Comment \begin{itshape} get first node out of queue\end{itshape}
            \State $visited.add(curNode);$ \Comment \begin{itshape} mark node as visited\end{itshape}            
                \If{$!curNode.equals(dest)$}
                \State {$return$ $dest;$}
                \EndIf
            \For{$Edge$ $e$ : $curNode.getEdges()$}
                \If{$!visited.contains(e.getNode2())$}
                    \If{$e.getNode2().getDistance() == curNode.getDistance() + 1 \| e.getNode2().getDistance() == -1$}
                        \State $alreadyVis \gets false;$
                        \For{$Node$ $node$ : $nodeQueue$}
                            \State $node.addParent(curNode);$
                            \State $alreadyVis \gets true;$
                            \State $break;$
                        \EndFor
                        \If{$!alreadyVis$}
                        \State $nodeQueue.offer(e.getNode2());$
                        \State $e.getNode2().addParent(curNode);$
                        \State $e.getNode2().setdistance(curNode.getDistance()+1);$
                        \EndIf
                    \EndIf
                \EndIf
            \EndFor
            \EndWhile


            
        \end{algorithmic}
    \end{algorithm}
    \subsection{Determination of the neighbour sets of a server and loads of the links}
    \begin{algorithm}[H]
        \caption{constraintsCalculation}
        \begin{algorithmic}[2]
            \Require Graph (V,E) G, Servers S
            \For{Each node n $\in G$}
                \If{!($n \in S$)}
                    \State $nearestServersList \gets \{\};$ 
                    \State $minServer \gets 0;$ \Comment The stepcounter to the nearest server(s)
                    \For {Each Server $ s \in S$}
                        \State $BFS2(n,s)$
                        \State $p \gets s;$
                        \State $i \gets 0;$ \Comment Count steps to server
                        \While {$!p.parents().isEmpty())$}
                            \State $i=i+1;$
                            \State $p \gets p.parents[0];$
                        \EndWhile
                        \If {$i \leq minServer || nearestServersList.isEmpty()$}
                            \If {$i < minServer$}
                                \For{Each Server prevNearest $\in nearestServersList$}
                                    \State $prevnearest.tmpNeighbourhood=0;$
                                    \State $nearestServersList.clear();$
                                    \State $usedEdges.clear();$
                                \EndFor
                            \EndIf
                            \State $minServer = i;$ \Comment new nearest server found, set length
                            \State $nearestServersList.add(s);$ \Comment add it to the list of nearest servers 
                            \State $s.tmpNeighbourhood += 1;$ \Comment adds one to the temporal neighbourhood (it may get reset later on)
                            \State $markPath2(s)$ \Comment This method recusively walks back every node's parents list to determine every path and add it to the usedEdges list.
                        \EndIf 
                    \EndFor
                        \For{Each Server s $\in nearestServerList$}
                            \State $s.neighborhood += s.tmpNeighbourhood;$
                            \State $s.tmpNeighbourhood = 0;$
                        \EndFor
                    \State $markEdges();$ \Comment increments usage of each usedEdges
                \EndIf
            \EndFor
        \end{algorithmic}
    \end{algorithm}
ewfw
    \subsection{The local search}
    \subsection{The tabu-search}
    \subsection{Networks and the approximation ratio}
\section{Conclusion}

\bibliography{bibtex}
\end{document}
